üìä Searching Algorithms ‚Äì Notes Table (‚≠ê on Top)

| No. | Algorithm (‚≠ê = Important) | Short Description                        | Time Complexity           | Space   | When to Use ‚úÖ                        | When NOT to Use ‚ùå                | Real-World Examples                                 |
|-----|---------------------------|------------------------------------------|--------------------------|---------|---------------------------------------|-----------------------------------|-----------------------------------------------------|
| 1   | ‚≠ê Linear Search           | Scan elements one by one until found     | O(n)                     | O(1)    | Small or unsorted arrays              | Large datasets (too slow)         | Searching a student in an unsorted attendance list   |
| 2   | ‚≠ê Binary Search           | Repeatedly divide sorted array into halves| O(log n)                 | O(1)    | Sorted arrays/lists                   | Unsorted data                     | Contact list search, dictionary word lookup          |
| 3   | ‚≠ê Exponential Search      | Double the range, then apply binary      | O(log n)                 | O(1)    | Infinite/unbounded sorted arrays      | Small datasets                    | Searching in infinite streams                        |
| 4   | ‚≠ê Hashing                 | Direct access using hash tables          | O(1) avg, O(n) worst     | O(n)    | Fast lookups in large data            | High memory cost                  | Caches, dictionaries, hash maps                      |
| 5   | ‚≠ê BFS (Graph)             | Explore neighbors level by level         | O(V+E)                   | O(V)    | Shortest path in unweighted graph     | Dense graphs (space heavy)        | Social network friend suggestions                    |
| 6   | ‚≠ê DFS (Graph)             | Explore depth-first, then backtrack      | O(V+E)                   | O(V)    | Cycle detection, pathfinding          | Very deep graphs (stack overflow) | Maze solving, dependency resolution                  |
| 7   | Jump Search               | Jump in fixed steps, then linear scan    | O(‚àön)                    | O(1)    | Sorted arrays, when binary is costly  | Unsorted data                     | Index lookups in books                               |
| 8   | Interpolation Search      | Uses formula to predict position         | O(log log n) avg, O(n) worst | O(1) | Uniformly distributed sorted data     | Skewed distributions              | Searching names in a phonebook                       |
| 9   | Ternary Search            | Divide into 3 parts instead of 2         | O(log n)                 | O(1)    | Optimizing unimodal functions         | Normal arrays (binary is better)  | Finding max/min in math problems                     |
| 10  | Fibonacci Search          | Uses Fibonacci numbers to split array    | O(log n)                 | O(1)    | Sorted arrays with few comparisons    | Complex to implement              | Search in large sorted datasets                      |